# 비트 마스킹

## 비트 연산자

> 비트 단위, 2진수 단위로 논리 연산을 위해 사용하는 연산자

비트 단위로 전체 비트를 오른쪽 → 왼쪽으로 이동시킬 때에도 사용한다.

주로 2진수로 변환하여 비교 후 결과 값을 10진수의 형태로 변환한다.

## 비트 연산자의 종류

### A | B (OR 연산자)

```js
console.log(1 | 3);
//   0001
// | 0011
// ------
//   0011(2) = 3
```

0과 만나면 자기 자신의 값을 1과 만나면 1이 나온다.

### A & B (AND 연산자)

```js
console.log(1 & 3);

//   0001
// & 1101
// -------
//   0001(2) = 1
```

0과 만나면 0이 1과 만나면 1이 나오게 되며 자기 자신과 자시 자신을 AND 연산 하면 자기 자신이 나오게 된다.

### A ^ B (XOR 연산자)

```js
console.log(1 ^ 3);

//   0001
// ^ 1101
// -------
//   1100(2) = 12
```

0과 만나면 자기 자신이 1과 만나면 자신의 값의 반대의 결과가 나오며, 자기 자신을 xor 하게되면 0으로 나오게 된다.

### ~ A (NOT 연산자)

```js
console.log(~1);

// 0001 -> 1110(2) -> 14
```

자신의 비트와 반대되는 값이 나오게 된다. 7인 이유는 integer는 보통 4bit이기 때문에 1이 0001이며, 0001을 NOT 연산하게 되면 1110이 되기 때문에 7이 된다.

### logical right shift

- 음, 양을 구분하는 부호 비트를 염두에 두지 않고 비트를 오른쪽으로 시프트 하는 연산

### A << B (left shift 연산자)

```js
console.log(1 << 3);
// 0001 -> 1000(2) -> 8

console.log(3 << 3);
// 0011 -> 11000(2) -> 24
```

left shift 연산은 a에 대해 b번 left 방향으로 이동 후 나머지 자리의 비트는 0으로 채워 계산한 연산을 의미한다.

### A >> B (right shift 연산자)

```js
console.log(4 >> 2);
// 0100 -> 0001(2) -> 1
```

right shift 연산은 a에 대해 b번 right 방향으로 이동 후 나머지 자리의 비트는 0으로 채워 계산한 연산을 의미한다.

## getBit(idx 번째 비트의 값을 가져오는 함수)

<img width="500" src="https://github.com/jinyoung234/Algorithm_JS/assets/87177577/3f829b46-da8f-45e7-90cd-835a7bba3444"/>

<img width="500" src="https://github.com/jinyoung234/Algorithm_JS/assets/87177577/f0e12026-c4db-4ecf-a00f-74484c766bbc"/>

예시로 target의 값이 9이고 i번째(3) 비트의 값을 찾으려고 할 땐 AND 연산을 통해 구할 수 있다.

and 비트 연산자는 원하는 i번째 인덱스를 1로 두고 나머지 값을 0으로 세팅하여 계산할 경우 x가 1이라면 1, 0이라면 0을 반환 하며 나머지 값은 모두 0으로 나오기 때문에 목적에 맞게 계산이 가능하다.

그렇다면 and 연산을 할 1000(mask)은 어떻게 만들 수 있을까?

<img width="500" src="https://github.com/jinyoung234/Algorithm_JS/assets/87177577/ec8de5da-2c21-4adb-8a7d-0b405a85c5be"/>

1을 i번 left shift를 하면 가능하다.

**예시 코드**

```js
function getBit(target, idx) {
  // target과 비교하기 위한 mask를 생성 (1을 idx번 left shift 연산)
  const mask = 1 << idx;
  // 만약 target과 mask를 and 연산했을 때 1이상이면 true 0이면 false가 반환된다.
  return target & mask ? true : false;
}

console.log(getBit(5, 3).toString(2));
//   0101
// & 1000
// -------
//   0000 -> 0이므로 false

console.log(getBit(9, 3).toString(2));
//   1001
// & 1000
// -------
//   1000 -> 가장 앞 자리 수가 1이므로 true
```

## setBit (i번째 비트를 1로 만들어주는 함수)

<img width="500" src="https://github.com/jinyoung234/Algorithm_JS/assets/87177577/68f6a38a-b491-45ec-8f7d-1f67727e2182"/>

getBit 에서의 target과 i번째 비교할 i를 세팅하고 target과 함께 연산할 값을 left shift를 통해 mask를 생성한다.

<img width="500" src="https://github.com/jinyoung234/Algorithm_JS/assets/87177577/595b2c96-628c-49e9-8147-56f44d79f4b3"/>

두 수를 or 연산해서 i번째 idx를 1로 세팅한다.

**예시 코드**

```js
function setBit(target, idx) {
  const mask = 1 << idx;
  return target | mask;
}

console.log(setBit(3, 3).toString(2));
//   0011
// | 1000
// -------
//   1011(2) -> 11
```

## clearBit

<img width="500" src="https://github.com/jinyoung234/Algorithm_JS/assets/87177577/ea39b7bc-0a26-4551-9887-7f9a121bac92"/>

clearBit는 주로 i번째 인덱스의 비트를 0으로 초기화하기 위해 사용된다.

target이 9일 때 3번째 idx의 비트를 0으로 만들려면 우선 1을 i번 만큼 left shift 후 not 연산을 해서 반전을 하게 되면 0번째 비트는 0, 나머지 비트는 1이 된다.

<img width="500" src="https://github.com/jinyoung234/Algorithm_JS/assets/87177577/a832d289-53a2-4cbe-82ca-194dd14cce2a"/>

모든 비트는 0과 and 연산을 하게 되면 0으로 반환되기 때문에 다음과 같이 and 연산을 통해 0으로 clear 시킬 수 있다.

**예시 코드**

```js
function clearBit(target, idx) {
  // setBit, getBit 처럼 left shift 연산 후
  // -1을 하여 비트 반전을 시킨다.
  const mask = (1 << idx) - 1;
  // 비트 반전된 mask와 target을 and 연산하면 i번째 비트가 0이 된다.
  return target & mask;
}

console.log(clearBit(9, 3).toString(2));
//   1001
// & 0111
// -------
//   0001(2) -> 1
```

## clearLeftBits

idx번째 부터 왼쪽의 비트들을 모두 0으로 만들어주는 함수 이며 메커니즘은 clearBit랑 동일하므로 생략한다.

## clearRightBits

> idx번째 부터 오른쪽 비트 들을 모두 0으로 만들어주는 함수

**예시 코드**

```js
function clearRightBit(target, idx) {
  // -1이 1111...1111(2)이므로 i+1 만큼 left shift 하여 1을 0으로 반전 시킨 mask를 생성
  const mask = -1 << (idx + 1);
  // idx 자리가 모두 0인 mask와 and 연산 하기 때문에 다음과 같은 값이 도출 된다.
  return target & mask;
}

console.log(clearRightBit(169, 3).toString(2));

// ... 10101001(2)
// ... 11110000(2)
// ---------------
// ... 10100000(2)
```

## updateBit

> i번째 인덱스를 1 or 0으로 업데이트 하는 함수

**예시 코드**

```js
function updateBit(target, idx, bool) {
  const mask = ~(1 << idx);
  return (target & mask) | ((bool ? 1 : 0) << idx);
}

console.log(updateBit(169, 3, false).toString(2));
```
