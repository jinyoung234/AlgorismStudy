# 에라토스테네스의 체

## 소수

> 양의 약수를 2개만 가지는데, 1과 자기 자신을 약수로 가지는 수

소수를 판별하기 위한 일반적인 소스 코드는 다음과 같다.

```js
const isPrime = (n) => {
  for (let i = 2; i < n; i++) {
    if (n % i === 0) return false;
  }
  return true;
};

console.log(isPrime(4)); // false
console.log(isPrime(23)); // true
```

isPrime 이라는 함수는 2부터 n보다 작은 숫자 까지 순회하며 n을 i로 나눈 나머지가 0이 될 경우 나누어 떨어지기 때문에 소수의 조건에서 벗어나게 되므로 false를 반환하고, for 문을 돌 때 까지 false를 반환하지 않게 되면 소수의 조건을 만족하기 때문에 true를 반환한다.

2 ~ n 까지의 모든 소수를 반환하는 알고리즘을 구현하는 방법은 다음과 같다.

```js
// 입력 받은 n이 소수 인지 판별하기 위해 2 ~ n - 1까지 나누어 떨어지는 숫자가 있는지 확인한다.
const isPrime = (n) => {
  for (let i = 2; i < n; i++) {
    if (n % i === 0) return false;
  }
  return true;
};

// 2 ~ n 까지 소수인지 확인 해서 소수라면 i를 출력한다.
const printPrimeNumber = (n) => {
  for (let i = 2; i <= n; i++) {
    if (isPrime(i)) console.log(i);
  }
};

printPrimeNumber(4);
// 2
// 3
```

해당 알고리즘에 대한 시간 복잡도는 O(n^2)을 소모 하게 된다.

<br/>

## 첫 번째 리팩토링

소수를 판별하는 부분에서 약간의 시간 복잡도를 줄일 수 있는 방법이 있다.

```js
const isPrime = (n) => {
  for (let i = 2; i <= Math.sqrt(n); i++) {
    if (n % i === 0) return false;
  }
  return true;
};
```

예시로 4의 약수를 구한다고 가정해보자.

4의 약수는 1 곱하기 4, 2 곱하기 2, 4 곱하기 1이다.

약수를 자세히 들여다보면 대칭 구조를 가지는 것을 확인할 수 있는데, 1 _ 4를 확인 하나 4 _ 1를 확인 하나 두 값은 서로 같은 값 이기 때문에 비교가 의미가 없게 된다.

그렇기 때문에 n의 제곱근 까지만 순회를 하면 동일한 알고리즘 이지만 시간 복잡도가 감소하게 된다.

<br/>

## 에라토스테네스의 체란?

> 수 많은 소수 들을 빠르게 구하기 위한 알고리즘

### 에라토스테네스의 체를 이용한 알고리즘의 과정

1. 1차원 배열을 생성 후 2 ~ 원하는 수 까지 자신의 인덱스의 자신의 값을 추가 한다.
2. 다시 i = 2 ~ 원하는 수 까지 순회

   2-1. i for 문에서 이미 약수가 아님이 확인 되었다면 (arr[i] == 0) continue로 넘어간다.

   2-2. j ⇒ i \* i(i의 다음 배수) ~ 원하는 수 까지 순회하며 각 i의 배수들은 소수가 아니므로 0으로 만들어 준다.

3. 다시 2 ~ 원하는 수를 순회하며 arr[i]가 0이 아니라면 소수이기 때문에 소수를 출력 한다.

### 예시

<img  width="600" src="https://github.com/jinyoung234/Algorithm_JS/assets/87177577/6c128185-7b40-4f81-9b49-e2b3e47be287"/>

1. 1차원 배열을 생성 하여 값을 초기화 한다.

<img  width="600" src="https://github.com/jinyoung234/Algorithm_JS/assets/87177577/c120b7eb-0fb4-41b3-8e10-070c2f9053c3"/>

2. 2의 배수 ~ n의 배수에 대해 약수가 아니므로 모두 지워준다.
3. 이미 지워진 숫자라면 건너뛴다.

<img  width="600" src="https://github.com/jinyoung234/Algorithm_JS/assets/87177577/c120b7eb-0fb4-41b3-8e10-070c2f9053c3"/>
4. 2부터 시작해서 배열에 있는 모든 소수 들을 출력한다.

**결과 = 2, 3, 5, 7, 11, 13, 17, 19, 23**

<br/>

## 에라토스테네스 체 구현

```js
const numbers = [];

const printPrimeNumber = (n) => {
  // 2 ~ n까지 순회하며 해당 인덱스의 자신의 값을 추가 한다.
  for (let i = 2; i <= n; i++) {
    numbers[i] = i;
  }
  // 2 ~ n의 배수에 대해서 소수가 아니기 때문에 0으로 초기화 한다.
  for (let i = 2; i <= n; i++) {
    // 이미 소수가 아닌 값이 발견 되었다면 건너뛴다.
    if (numbers[i] === 0) continue;
    // i의 배수 다음 숫자 부터 n까지 i의 배수에 대해 0으로 초기화
    for (let j = i * i; j <= n; j += i) {
      numbers[j] = 0;
    }
  }
  // 2 ~ n까지의 소수를 출력
  for (let i = 2; i <= n; i++) {
    if (numbers[i] !== 0) console.log(i);
  }
};

printPrimeNumber(4);
printPrimeNumber(23);
```

<br/>

## 에라토스테네스의 장점

1. 주어진 범위 내에서 소수를 찾을 때 연산 횟수가 적다.

   1-1. 미리 정해진 범위에서 소수를 찾기 때문에 일반적인 방법 보다 더 빠르게 소수를 찾을 수 있다.

2. 소수의 배수도 찾을 수 있다.
   <br/>

# 레퍼런스

- https://www.youtube.com/watch?v=5ypkoEgFdH8
